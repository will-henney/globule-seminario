# -*- coding: utf-8 -*-
"""m1-67-globules-hst.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A7v8CkXAqPXEItCsdPjy0r9Pba96rqJO

# Measure properties of M1-67 globules from HST H alpha images

## Install and import packages

These packages are not in the default colab environment, so we must install them with pip.
"""

!pip install astroquery regions cmasher --quiet

from astroquery.mast import Observations
from astropy.io import fits
import astropy.units as u
from astropy.wcs import WCS
import regions

from matplotlib import pyplot as plt
import seaborn as sn
sn.set_context("notebook")
import cmasher as cm

"""I made a gist of my discrete gaussian code, although I could have grabbed it directly I suppose.  """

user = "will-henney"
repo = "efd581c724e8c591a7f50e9e576f2980"
src_dir = "c520092b65fb2b88838c9d04987ceb74af86b8f1"
pyfile = "discrete_gaussian_model.py"

url = f"https://gist.githubusercontent.com/{user}/{repo}/raw/{src_dir}/{pyfile}"
! wget --no-cache --backups=1 {url}

from discrete_gaussian_model import DiscreteGaussianModel

"""## Download data from MAST archive

Get a list of all the dtatsets that have been processed by the Hubble Legacy Archive and that use the Ha filter.

*Note that the older instruments like WFPC2 are not available from Amazon AWS, so we need to get the data directly from the archive.*
"""

table = Observations.query_criteria(
    objectname="WR124", 
    radius="1 arcmin",
    filters=["F656N"],
    project="HLA",
    )
table.remove_column("s_region")

table

"""To start with, we will just use the WFC image from the second epoch """

products = Observations.get_product_list(table)

"""And we only want the final drizzled images"""

filtered = Observations.filter_products(products,
                                        obs_id="hst_11137_01_wfpc2_f656n_wf",
                                        productSubGroupDescription='DRZ')

filtered

"""The first file is the one we want:"""

manifest = Observations.download_products(filtered[0], productType="SCIENCE")

manifest

fn = manifest[0]["Local Path"]

hdulist = fits.open(fn)
hdulist.info()

"""## Plot image of data"""

hdu = hdulist['SCI']
wcs = WCS(hdu)
wcs

import numpy as np
from astropy.visualization import simple_norm
from astropy.coordinates import SkyCoord

"""Get celestial coordinates of central WR star"""

c0 = SkyCoord.from_name('wr124', cache=True)
c0

"""Convert to pixel coordinates and define the size of the window we want to plot (in pixels, which are  0.1 arcsec)"""

x0, y0 = wcs.world_to_pixel(c0)
mx, my = 600, 600

fig = plt.figure()
ax = fig.add_subplot(projection=wcs)
norm = simple_norm(hdu.data, stretch='log', min_cut=0, max_cut=3)
im = ax.imshow(hdu.data, norm=norm, cmap=cm.ember)
cb = fig.colorbar(im, ax=ax, ticks=[0.01, 0.1, 1.0, 3.0])
ax.set(
    xlim=[x0 - mx, x0 + mx],
    ylim=[y0 - my, y0 + my],
)
...;

"""## Plot brightness versus radius

Get the angular separation of each image pixel from the central star
"""

ny, nx = hdu.data.shape
xpix, ypix = np.meshgrid(np.arange(nx), np.arange(ny))
pixcoords = wcs.pixel_to_world(xpix, ypix)
seps = c0.separation(pixcoords)
seps.arcsec.min(), seps.arcsec.max()

goodpixels = hdu.data > 0.0
radius = seps.arcsec[goodpixels]
brightness = hdu.data[goodpixels]

brightness.min(), brightness.max()

"""Make a histogram of the radius and brightness on a log scale."""

rmin, rmax = 0.5, 1.02 * radius.max()
bmin, bmax = 0.001, 5.0
ymin, ymax = np.log10(bmin), np.log10(bmax)
xmin, xmax = np.log10(rmin), np.log10(rmax)
H, yedges, xedges = np.histogram2d(
    np.log10(brightness),
    np.log10(radius),
    bins=300,
    range=[[ymin, ymax], [xmin, xmax]],
    weights=brightness,
    density=True,
)
H.sum() * (ymax - ymin) * (xmax - xmin) / np.product(H.shape)

HH = np.where(H == 0.0, np.nan, H)

from matplotlib.colors import PowerNorm

"""And plot the histogram."""

fig, ax = plt.subplots(figsize=(8, 6))
im = ax.imshow(
    HH, 
    origin="lower", 
    norm=PowerNorm(gamma=0.5, vmin=0.0, vmax=5),
    cmap="inferno_r", 
    extent=[xmin, xmax, ymin, ymax], 
    aspect="auto",
    interpolation="none",
)

fig.colorbar(im, ax=ax, label="Flux-weighted joint probability density")
ax.set(
    xlabel=r'$\log_{10}$ (Separation, arcsec)',
    ylabel=r'$\log_{10}$ (Brightness)',
    title=f"M1-67 – histogram version",
)
...;

"""Note that we have a bunch of spurious bright pixels for radii > 45"""

badpix = (radius > 45.0) & (brightness > 0.3)
brightness[badpix] = np.nan

"""Now do the same but with a linear radius scale and a sqrt brightness scale. """

rmin, rmax = 0.0, 70.0
bmin, bmax = 0.0, 4.0
ymin, ymax = np.sqrt(bmin), np.sqrt(bmax)
xmin, xmax = rmin, rmax
H, yedges, xedges = np.histogram2d(
    np.sqrt(brightness),
    radius,
    bins=(100, 200),
    range=[[ymin, ymax], [xmin, xmax]],
    weights=brightness,
    density=True,
)
H.sum() * (ymax - ymin) * (xmax - xmin) / np.product(H.shape)

HH = np.where(H == 0.0, np.nan, H)
HH /= np.nansum(HH) / np.isfinite(HH).sum()
fig, ax = plt.subplots(figsize=(8, 4))
im = ax.imshow(
    HH, 
    origin="lower", 
    norm=PowerNorm(gamma=1.0, vmin=0.0, vmax=5.0),
    cmap=cm.arctic_r,
    extent=[xmin, xmax, ymin, ymax], 
    aspect="auto",
    interpolation="none",
)

fig.colorbar(im, ax=ax, label="Flux-weighted joint probability density")
ax.set(
    xlabel=r'(Separation, arcsec)',
    ylabel=r'sqrt (Brightness)',
    title=f"M1-67 – histogram version",
)
...;

fig.savefig("m1-67-global-brightness-profile.pdf", bbox_inches='tight')

"""This shows the structure much better. We see the multiple shells in the nebula. The color is proportional to the fraction of the total nebular emission that comes from that cobination of suface brightness and radius. This tends to be maximum for the median brightness, but the peak brightnesses are also a significant fraction (but never a majority)

## Flux calibration of the image

We use the total Ha flux of the nebula, as measured by Grosdidier. This is the value that is supposedly corrected for nii contamination and for foreground extinction.
"""

flux_nebula_total = 2.08e-10 * u.erg / u.s / u.cm**2

"""We need to compare this with the sum of all the pixels in the image, but discounting the stars and the artifacts.  We have already dealt with some of that in calculating the `brightness` array above. I will also exclude the central star, and then count it all up. """

nebula_bright = brightness.copy()
nebula_bright[brightness > 3.0] = np.nan
nebula_bright[radius < 1] = np.nan
nebula_bright[radius > 60] = np.nan
counts_nebula_total = np.nansum(nebula_bright)
counts_nebula_total, np.isfinite(nebula_bright).sum()

flux_per_counts = flux_nebula_total / counts_nebula_total
flux_per_counts

pixel_area = ((0.1 * u.arcsec)**2).to(u.sr)
pixel_area

"""## Look at the globules

Get the region file from the Github repo of the Roberto seminario project:
"""

region_url = (
    "https://raw.githubusercontent.com/"
    "will-henney/globule-seminario/"
    "main/m1-67/m1-67-globules.reg"
    )

"""Select only those regions that are circle points, since those are the ones that are the globules."""

regs = regions.Regions.read(region_url, format="ds9")
regs = [_ for _ in regs if hasattr(_, 'center') and _.visual.get('marker') == "o"]

len(regs)

"""That is the correct number that I had counted before. 

Now look at the visual properties of the regions:
"""

regs[0].visual

"""Select those with thicker borders, which are the ones I judged to be well isolated"""

rregs = [_ for _ in regs if _.visual.get('markeredgewidth') == 3]
len(rregs)

"""Make a table of the globule sources.

*Aside: is "globule" a good term?  In the Helix, we have "cometary knots". There are "cometary globules" around H II regions, but those are larger. Then there is Gaum's term of "globulettes" for the smaller versions, such as in the Rosette.*
"""

from astropy.table import QTable, Table

source_table = QTable(
    [
        {"ICRS": r.center, "Isolated": r.visual.get('markeredgewidth') == 3} 
        for r in regs
    ]
)

"""Add columns for position angle and separation from star. Unlike the previous case with the proplyds, we want the PA of the globule wrt to the star, not the other way around. """

source_table["PA"] = c0.position_angle(source_table["ICRS"]).to(u.deg)
source_table["Sep"] = source_table["ICRS"].separation(c0).to(u.arcsec)
source_table["PA"].info.format = ".2f"
source_table["Sep"].info.format = ".2f"

source_table.show_in_notebook()

"""### Spatial distribution of globules

Plot the spatial distribution of the globules on PA, separation plane.
"""

sn.set_color_codes()
g = sn.jointplot(
    x=source_table['PA'].value, 
    y=source_table['Sep'].value,
    height=6, space=0.3, ratio=4,
    marginal_kws={'shrink': 0.95, 'lw': 0, 'bins': 10},
    )
g.plot_joint(sn.kdeplot, bw_adjust=0.4, color="r", zorder=0, levels=9)
g.plot_marginals(sn.rugplot, color="r", alpha=0.5, height=-.15, clip_on=False)
g.figure.axes[0].set(
    xlim=[0, 360],
    ylim=[0, 37],
    xlabel='Position angle, deg',
    ylabel='Separation, arcsec',
)
g.figure.axes[1].set(ylim=[0, 40])
g.figure.axes[2].set(xlim=[0, 40])

...;

g.figure.savefig('m1-67-globules-pa-sep-jointplot.pdf', bbox_inches='tight')

"""### Brightness profile of individual globules

First we will make an image cutout
"""

source = source_table[0]
source

j1, i1 = wcs.world_to_array_index(source['ICRS'])
size = 15
yslice, xslice = slice(j1 - size, j1 + size), slice(i1 - size, i1 + size)
cutout = hdu.data[yslice, xslice]
wcutout = wcs.slice((yslice, xslice))
wcutout

fig = plt.figure()
ax = fig.add_subplot(projection=wcutout)
im = ax.imshow(cutout, vmin=0.0, cmap=cm.neutral)
cb = fig.colorbar(im, ax=ax)
x1, y1 = wcutout.world_to_array_index(source['ICRS'])
arrow_length = 5.0
dx, dy = arrow_length * np.sin(source['PA']), -arrow_length * np.cos(source['PA'])
ax.arrow(x1, y1, dx, dy, color='r', lw=3)
ax.set_title(f"PA = {source['PA']:.1f}, separation = {source['Sep']:.1f}")
...;

"""That worked, but we can simplify things by using astropy.nddata.Cutout2D(). The following class is based on what I did for the Julia+Tom proplyd project, but modified for our needs"""

from astropy.nddata import Cutout2D
from astropy.coordinates import Angle

class SourceCutout:
    """Small image cut out around a given source
    """
    
    def __init__(self, pdata, hdu, size=3 * u.arcsec):
        self.center = pdata["ICRS"]
        # PA of source wrt star
        self.pa_source = pdata["PA"]
        # and PA of star wrt source
        self.pa_star = Angle(self.pa_source + 180 * u.deg).wrap_at(360 * u.deg)
        self.sep = pdata["Sep"]
        self.is_isolated = pdata["Isolated"]
        self.size = size
        self.cutout = Cutout2D(
            hdu.data, position=self.center, size=size, wcs=WCS(hdu), copy=True,
        )
        self.image = self.cutout.data
        self.wcs = self.cutout.wcs
        ny, nx = self.image.shape
        self.x, self.y = np.meshgrid(np.arange(nx), np.arange(ny))
        self.image_coords = self.wcs.pixel_to_world(self.x, self.y)
        # Radius and PA of each pixel with respect to the NOMINAL center
        self.r = self.center.separation(self.image_coords)
        self.pa = self.center.position_angle(self.image_coords)
        # Default mask has max radius of half the cutout size
        self.set_mask(r_out=self.size / 2)

        self.find_bary_center()
        # Recalculate r, pa, and masks wrt the barycenter
        self.r = self.barycenter.separation(self.image_coords)
        self.pa = self.barycenter.position_angle(self.image_coords)
        self.set_mask(r_out=self.size / 2)

        # And do photometry
        self.bright_peak = np.max(self.image[self.coremask])
        # Take the 10% centile as estimate of BG value
        self.bright_bg = np.percentile(
            self.image[self.mask],
            10,
        )
        # BG-subtracted of the core region
        self.flux_core = np.sum((self.image - self.bright_bg)[self.coremask])
        # BG-subtracted part of the outer part within the mask but excluding core
        self.flux_halo = np.sum(
            (self.image - self.bright_bg)[(~self.coremask) & self.mask]
            )

        
    def __repr__(self):
        return f"SourceCutout({self.pa_source:.1f}, {self.sep:.1f})"
       
         
    def set_mask(
        self,
        r_out = 1.0 * u.arcsec,
        r_in = 0.2 * u.arcsec,
        r_core = 0.2 * u.arcsec,
        mu_min = 0.5,
    ):
        cth = np.cos((self.pa - self.pa_star))
        self.mask = (self.r <= r_out) & ((cth >= mu_min) | (self.r <= r_in))
        self.coremask = (self.r <= r_in)

    def find_bary_center(self):
        """Refine estimate of center by using flux-weighted mean
        position within the core mask
        """
        m = self.coremask

        # Original version was flux-weighted mean
        # xbary = np.average(self.x[m], weights=self.image[m])
        # ybary = np.average(self.x[m], weights=self.image[m])

        # New version is just the peak pixel
        index = np.argmax(self.image[m], axis=None)
        xbary = self.x[m][index]
        ybary = self.y[m][index]

        self.barycenter = self.wcs.pixel_to_world(xbary, ybary)

source = source_table[45]
cutout = SourceCutout(source, hdu)

fig = plt.figure()
ax = fig.add_subplot(projection=cutout.wcs)
im = ax.imshow(
    cutout.image,
    vmin=0.0, 
    cmap=cm.neutral,
    )
cb = fig.colorbar(im, ax=ax)
ax.imshow(np.where(cutout.mask, np.nan, 1.0), vmin=0, vmax=1, cmap=cm.gem, alpha=0.3)
y1, x1 = cutout.wcs.world_to_array_index(cutout.barycenter)
arrow_length = 5.0
dx, dy = -arrow_length * np.sin(cutout.pa_star), arrow_length * np.cos(cutout.pa_star)
ax.arrow(x1, y1, dx, dy, color='r', lw=3)
ax.set_title(f"PA = {cutout.pa_source:.1f}, separation = {cutout.sep:.1f}")
...;

fig, ax = plt.subplots()
m = cutout.mask
ax.scatter(
    cutout.r[m].arcsec, 
    cutout.image[m], 
    c=Angle(cutout.pa - cutout.pa_star).wrap_at(180*u.deg).deg[m], 
    vmin=-60, vmax=60,
    cmap=cm.watermelon)

cutout.bright_peak

cutouts = [SourceCutout(source, hdu) for source in source_table]
cutouts = sorted(cutouts, key=lambda x: x.sep.value)

best_cutouts = [cutout for cutout in cutouts if cutout.is_isolated]

fig = plt.figure(figsize=(14, 14))
for idx, cutout in enumerate(best_cutouts):
    ax = fig.add_subplot(7, 7, idx + 1)
    im = ax.imshow(cutout.image, vmin=0.0,  cmap=cm.neutral_r, origin='lower')
    ax.imshow(np.where(cutout.mask, np.nan, 1.0), vmin=0, vmax=1, cmap=cm.gem, alpha=0.1, origin='lower')
    x1, y1 = cutout.wcs.world_to_pixel(cutout.barycenter)
    arrow_length = 5.0
    dx, dy = -arrow_length * np.sin(cutout.pa_star), arrow_length * np.cos(cutout.pa_star)
    ax.arrow(x1, y1, dx, dy, color='r', width=0.5, head_width=1.5, length_includes_head=True, )
    ax.text(0.05, 0.95, rf'PA = {round(cutout.pa_source.value):03d}$^\circ$', transform=ax.transAxes, va="top", ha="left")
    ax.text(0.95, 0.95, rf"$R = {cutout.sep.value:.1f}''$", transform=ax.transAxes, va="top", ha="right")
    ax.text(0.05, 0.05, rf"Peak: {cutout.bright_peak:.2f}", transform=ax.transAxes, va="bottom", ha="left")

    ax.set(xlabel="", ylabel="", xticks=[], yticks=[])
sn.despine(left=True, bottom=True)
fig.tight_layout(pad=0, h_pad=0.1, w_pad=0.1)
...;

fig.savefig("m1-67-globules-stamps-7x7.pdf")
fig.savefig("m1-67-globules-stamps-7x7.jpg", dpi=200)

nbins = 15
fig = plt.figure(figsize=(21, 21))
for idx, cutout in enumerate(best_cutouts):
    ax = fig.add_subplot(7, 7, idx + 1)
    m = cutout.mask
    ax.scatter(
        cutout.r[m].arcsec, 
        cutout.image[m], 
        c=Angle(cutout.pa - cutout.pa_star).wrap_at(180*u.deg).deg[m], 
        vmin=-60, vmax=60,
        cmap=cm.seaweed)
    h1, edges = np.histogram(cutout.r.arcsec[m], range=[0.0, 1.5], bins=nbins, weights=cutout.image[m])
    h0, edges = np.histogram(cutout.r.arcsec[m], range=[0.0, 1.5], bins=nbins)
    rgrid = 0.5 * (edges[1:] + edges[:-1])
    ax.plot(rgrid, h1 / h0, drawstyle="steps-mid", linewidth=9, c='r', alpha=0.5)

    ax.text(0.05, 0.95, rf'PA = {round(cutout.pa_source.value):03d}$^\circ$', transform=ax.transAxes, va="top", ha="left")
    ax.text(0.95, 0.95, rf"$R = {cutout.sep.value:.1f}''$", transform=ax.transAxes, va="top", ha="right")
    ax.set(xlabel="", ylabel="", ylim=[0.0, None])
sn.despine()
fig.tight_layout(h_pad=0.3, w_pad=0.3)
...;

fig.savefig("m1-67-globules-profiles-7x7.pdf")

"""### Add the globules to the brightness trend graph"""

rglob = [cutout.sep.value for cutout in cutouts]
bglob = [cutout.bright_peak for cutout in cutouts]
paglob = [cutout.pa_source.value for cutout in cutouts]

fig, ax = plt.subplots(figsize=(8, 4))
im = ax.imshow(
    HH, 
    origin="lower", 
    norm=PowerNorm(gamma=1.0, vmin=0.0, vmax=5.0),
    cmap=cm.arctic_r,
    extent=[xmin, xmax, ymin, ymax], 
    aspect="auto",
    interpolation="none",
)
ax.scatter(
    rglob, np.sqrt(bglob), 
    c=paglob, marker='.', cmap=cm.flamingo,
    vmin=-180, vmax=540,
    label='Globule peak brightness')
fig.colorbar(im, ax=ax, label="Flux-weighted joint probability density")
ax.legend()
ax.set(
    xlabel=r'Projected radius from star, arcsec)',
    ylabel=r'sqrt (Brightness)',
    title=f"M1-67 – plus globules",
)
...;

fig.savefig("m1-67-global-brightness-plus-globules.pdf", bbox_inches='tight')

"""The brightest globules sit on the peaks of the general brightness distribution, but there is a distribution towards fainter globules at each radius. 

There is a shallow tendency towards lower brightness at larger radii. It looks like it is roughly $B(r) \propto r^{-1}$. *Note that the graph shows sqrt of brightness*

### Calibrated flux of the globules
"""

best_cutouts[2].flux_core

sn.histplot(
    {"Flux": [_.flux_core for _ in cutouts]}
)

np.sum([_.flux_core for _ in cutouts]) / counts_nebula_total

"""So it seems that the total flux of the globules is less than 2% of the flux of the nebula. 

We can compare this with the fraction of the ionizing photons that should be trapped by the globules, which is equal to the area covering fraction.  Assume that radius is 0.2 arcsec for each globule, than $\pi r^2 / 4 \pi R^2$ is the fraction for each globule. 
"""

np.sum([(0.5 * 0.2 * u.arcsec/ _.sep)**2 for _ in cutouts])

"""Now that is a very simlar number, which is odd since we reckoned that the majority of the nebula was matter-bounded.

Estimate the number of recombinations/second in the nebula, based on the H alpha flux. 
"""

from astropy import constants

E_ha = (constants.h * constants.c / (6563 * u.angstrom)).cgs
E_ha

D = 5.429 * u.kpc
L_ha = (4 * np.pi * D**2).cgs * flux_nebula_total
L_ha

total_recombs = L_ha / E_ha
total_recombs

"""Now that value is small, as expected, so there must be somethhig wrong with the estimate of the covering fraction

### Fit gaussians to the brightness profiles

We can fit one Gaussian centered on zero to represent the globule, and another to represent the shell, and plus a constant
"""

from astropy.modeling import models, fitting
from astropy.modeling.models import Const1D
FITTER = fitting.LevMarLSQFitter()

def fit_to_cutout(cutout):
    g0 = DiscreteGaussianModel(
        amplitude=3.0, mean=0.0, stddev=0.1, 
        bin_width=0.1, fixed={"bin_width": True},
        )
    g0.mean.fixed = True
    g0.stddev.bounds = 0.01, 0.5
    g0.amplitude.bounds = 0.01, 20.0

    g1 = DiscreteGaussianModel(
        amplitude=3.0, mean=0.5, stddev=0.2,
        bin_width=0.1, fixed={"bin_width": True},
        )
    g1.mean.bounds = 0.1, 1.5
    g1.stddev.bounds = 0.01, 1.0
    g1.amplitude.bounds = 0.01, 20.0

    c0 = Const1D(amplitude=cutout.bright_bg)
    c0.amplitude.bounds = 0.0, 1.5 * cutout.bright_bg

    model = g0 + g1 + c0
    m = cutout.mask
    r = cutout.r[m].arcsec
    b = cutout.image[m]
    th = Angle(cutout.pa - cutout.pa_star).wrap_at(180*u.deg)[m]
    w = np.cos(th)**2 / (0.3 + r)**2

    cutout.fitted = FITTER(model, r, b, weights=w)
    cutout.core_sigma = cutout.fitted.stddev_0.value
    cutout.shell_radius = cutout.fitted.mean_1.value
    cutout.shell_sigma = cutout.fitted.stddev_1.value
    cutout.core_peak = cutout.fitted[0](0.0)
    cutout.shell_peak = cutout.fitted[1](cutout.shell_radius)
    cutout.bg_fit_level = cutout.fitted.amplitude_2.value

cutout = best_cutouts[0]
fit_to_cutout(cutout)

cutout.fitted

fig, ax = plt.subplots()
ax.scatter(
    cutout.r[m].arcsec, 
    cutout.image[m], 
    c=Angle(cutout.pa - cutout.pa_star).wrap_at(180*u.deg).deg[m], 
    vmin=-60, vmax=60,
    cmap=cm.seaweed)
rgrid = np.linspace(0.0, 1.5, 16)
ax.plot(rgrid, cutout.fitted(rgrid), drawstyle="steps-mid", linewidth=9, c='r', alpha=0.5)
for component in cutout.fitted:
    ax.plot(rgrid, component(rgrid), drawstyle="steps-mid", linewidth=3, alpha=0.8)

for cutout in cutouts:
    fit_to_cutout(cutout)

fig = plt.figure(figsize=(39, 39))
for idx, cutout in enumerate(cutouts):
    ax = fig.add_subplot(13, 13, idx + 1)
    m = cutout.mask
    ax.scatter(
        cutout.r[m].arcsec, 
        cutout.image[m], 
        c=Angle(cutout.pa - cutout.pa_star).wrap_at(180*u.deg).deg[m], 
        vmin=-60, vmax=60,
        cmap=cm.seaweed)
    
    rgrid = np.linspace(0.0, 1.5, 16)
    ax.plot(rgrid, cutout.fitted(rgrid), drawstyle="steps-mid", linewidth=9, c='r', alpha=0.5)
    for component in cutout.fitted:
        ax.plot(rgrid, component(rgrid), drawstyle="steps-mid", linewidth=3, alpha=0.8)

    ax.text(0.05, 0.95, rf'PA = {round(cutout.pa_source.value):03d}$^\circ$', transform=ax.transAxes, va="top", ha="left")
    ax.text(0.95, 0.95, rf"$R = {cutout.sep.value:.1f}''$", transform=ax.transAxes, va="top", ha="right")
    ax.set(xlabel="", ylabel="", ylim=[0.0, None])
sn.despine()
fig.tight_layout(h_pad=0.3, w_pad=0.3)
...;

fig.savefig("m1-67-globules-profiles-fits-13x13.pdf")

fig = plt.figure(figsize=(26, 26))
for idx, cutout in enumerate(cutouts):
    ax = fig.add_subplot(13, 13, idx + 1)
    im = ax.imshow(
        cutout.image, 
        vmin=0.5 * cutout.bright_bg,  
        vmax=max(cutout.bright_peak, 2 * cutout.shell_peak) + cutout.bright_bg, 
        cmap=cm.neutral_r, 
        origin='lower',
        )
    x1, y1 = cutout.wcs.world_to_pixel(cutout.barycenter)
    arrow_length = 5.0
    dx, dy = -arrow_length * np.sin(cutout.pa_star), arrow_length * np.cos(cutout.pa_star)
    ax.arrow(x1, y1, dx, dy, color='r', width=0.5, head_width=1.5, length_includes_head=True, )

    # Plot the sigma of core peak as circle
    angles = np.linspace(0, 360, 100) * u.deg
    rcore = cutout.core_sigma / 0.1 # in pixels
    x = x1 + rcore * np.cos(angles)
    y = y1 + rcore * np.sin(angles)
    ax.plot(x, y, color='r')

    # Plot the shell
    angles = np.linspace(
        cutout.pa_star - 60 * u.deg, 
        cutout.pa_star + 60 * u.deg, 
        100,
        )
    if cutout.shell_peak > 0.1 and cutout.shell_sigma/2 < cutout.shell_radius:
        for shift, ls, lw in zip([-1, 0, 1], ["-", ":", "-"], [1, 2, 1]):
            rshell = (cutout.shell_radius 
                      + shift * cutout.shell_sigma/2) / 0.1
            x = x1 - rshell * np.sin(angles)
            y = y1 + rshell * np.cos(angles)
            ax.plot(x, y, color='c', lw=lw, ls=ls)

    ax.text(0.05, 0.95, rf'PA = {round(cutout.pa_source.value):03d}$^\circ$', transform=ax.transAxes, va="top", ha="left")
    ax.text(0.95, 0.95, rf"$R = {cutout.sep.value:.1f}''$", transform=ax.transAxes, va="top", ha="right")
    ax.text(0.05, 0.05, rf"Peak: {cutout.bright_peak:.2f}", transform=ax.transAxes, va="bottom", ha="left")

    ax.set(xlabel="", ylabel="", xticks=[], yticks=[])
sn.despine(left=True, bottom=True)
fig.tight_layout(pad=0, h_pad=0.1, w_pad=0.1)
...;

fig.savefig("m1-67-globules-stamps-shells-13x13.pdf")

"""### Classify globules into spatial groups

Either do it by hand, or maybe use gaussian mixtures. Or just define ranges of PA and separation. 

I have now done this in Affinity by hand:


"""

from dataclasses import dataclass

@dataclass
class GlobuleGroup:
    """A spatial group of globules defined as a rectangle in PA, Sep space"""
    name: str
    pa0: u.Quantity["angle"]
    sep0: float
    dpa: u.Quantity["angle"] = 60 * u.deg
    dsep: float = 5.0

    def contains(self, pa, sep) -> bool:
        """Is a given PA, and Sep inside the box or not?"""
        Dsep = abs(sep - self.sep0)
        sep_check =  Dsep <= self.dsep / 2
        Dpa = abs(Angle(pa - self.pa0).wrap_at(180 * u.deg)) 
        pa_check = Dpa <= self.dpa / 2
        # print(Dsep, sep_check, Dpa, pa_check)
        return sep_check and pa_check

gg = GlobuleGroup("NE-04", 15 * u.deg, 3.5, 150 * u.deg,  7.0)
gg.contains(350 * u.deg, 3.0)

globule_groups = [
    GlobuleGroup("NE-04", 15 * u.deg, 3.5, 150 * u.deg,  7.0),
    GlobuleGroup("S-07", 200 * u.deg, 7.5, 100 * u.deg,  4.0),
    GlobuleGroup("W-08", 270 * u.deg, 9.0, 60 * u.deg,  6.0),
    GlobuleGroup("N-10", 350 * u.deg, 9.5, 60 * u.deg,  5.0),
    GlobuleGroup("S-12", 195 * u.deg, 12.0, 90 * u.deg,  6.0),
    GlobuleGroup("E-13", 70 * u.deg, 12.0, 100 * u.deg,  11.0),
    GlobuleGroup("N-16", 350 * u.deg, 17.0, 60 * u.deg,  8.0),
    GlobuleGroup("E-20", 90 * u.deg, 20.0, 40 * u.deg,  6.0),
    GlobuleGroup("S-20", 200 * u.deg, 20.0, 100 * u.deg,  8.0),
    GlobuleGroup("W-21", 280 * u.deg, 21.0, 40 * u.deg,  8.0),
    GlobuleGroup("E-27", 90 * u.deg, 29.0, 60 * u.deg,  8.0),
    GlobuleGroup("SW-27", 210 * u.deg, 27.0, 120 * u.deg,  6.0),
    GlobuleGroup("N-27", 340 * u.deg, 26.0, 60 * u.deg,  6.0),
    GlobuleGroup("S-33", 160 * u.deg, 34.0, 40 * u.deg,  4.0),

]

def assign_to_group(pa: u.Quantity["angle"], sep: u.Quantity["angle"]) -> str:
    for _group in globule_groups:
        if _group.contains(pa, sep.to(u.arcsec).value):
            # The first match is the one we use
            return _group.name
    # Case of no match
    return None

assign_to_group(10 * u.deg, 18 * u.arcsec)

"""### Make a table of all the globules with columns for properties

Export it to cvs for more analysis in a separate notebook, since this one is getting a bit long
"""

results = []
for cutout in cutouts:
    results.append(
        {
            "PA": cutout.pa_source,
            "Sep": cutout.sep,
            "Bcore": cutout.core_peak,
            "Bshell": cutout.shell_peak,
            "Bbg": cutout.bg_fit_level,
            "Rcore": cutout.core_sigma * u.arcsec,
            "Rshell": cutout.shell_radius * u.arcsec,
            "Hshell": cutout.shell_sigma * u.arcsec,
            "Group": assign_to_group(cutout.pa_source, cutout.sep)
         }
    )
results_table = QTable(results)
for col in results_table.itercols():
    try:
        col.info.format = ".2f"
    except ValueError:
        pass

results_table

def nanify(col, vmin=None, vmax=None, extras=[]):
    if vmin is not None:
        for _col in [col] + extras:
            results_table[_col][results_table[col].value <= vmin] = np.nan
    if vmax is not None:
        for _col in [col] + extras:
            results_table[_col][results_table[col].value >= vmax] = np.nan

nanify("Bcore", 0.01)
nanify("Bshell", 0.03, extras=["Rshell", "Hshell"])
nanify("Rcore", 0.01, 0.4)
nanify("Rshell", 0.1, 1.5, extras=["Bshell", "Hshell"])
nanify("Hshell", 0.01, 1.0, extras=["Rshell", "Bshell"])

results_table["Lat"] = 90 * u.deg - np.abs(np.abs(Angle(results_table["PA"] - 45 * u.deg).wrap_at(180 * u.deg)) - 90 * u.deg)

results_table

results_table.write("m1-67-globule-parameters.ecsv", overwrite=True)

import pandas as pd

df = results_table.to_pandas()
df

df.describe()

cdf = df.corr(numeric_only=True)
cdf

sol = (cdf.where(np.triu(np.ones(cdf.shape), k=1).astype(bool))
                  .stack()
                  .sort_values(ascending=False, key=np.abs))
sol.head(10)

"""So the most important positive correlations are Rcore–Rshell and Bcore-Bshell. The negative ones are Sep–Bcore, Sep–Bshell, and Bshell-Rshell. """

g = sn.pairplot(df, dropna=True)
g.map_upper(sn.kdeplot, levels=4, color='r')

g.figure.savefig('m1-67-globules-multi-pairplot.pdf', bbox_inches='tight')

"""### $\color{red}{\textbf{TODO}}$ Make one image per spatial group
* With similar annotations to the `stamps-shells-13x13` figure above, but with multiple globules in each image. 
* Put the accompanying shell profiles next to it, and add in the JWST image of the same field

### Add the globules to the image of the nebula

## Future plans
Maybe in different notebooks

### Do a low-pass filtering and then divide by it to get unsharp masked image
"""

